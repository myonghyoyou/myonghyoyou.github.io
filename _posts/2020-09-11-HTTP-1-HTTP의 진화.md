---
title: HTTP (1) HTTP의 진화
tags: HTTP
article_header:
  type: cover
  image: 
      src: 
---

### 개요
HTTP는 월드 와이드 웹에 내재된 프로토콜로 팀 버너스리에 의해서 1989년부터 1991년에 발명되었다. 주로 HTML로 작성된 문서를 주고받기 위해 사용되었으며, 꾸준한 확장과 수정을 통해
현대 인터넷의 핵심적인 요소로 자리잡게 되었다.
<br>

---

### 월드 와이드 웹의 발명
1989년 팀 버너스리는 Mesh라고 불리는 인터넷 상의 하이퍼텍스트 시스템을 만들게 된다. 그 후 1990년에 구현 과정에서 월드 와이드 웹으로 이름이 바뀌게 되고
기존의 TCP 그리고 IP 프로토콜 상에서 만들어지며 4개의 요소로 구성되어진다.

<ul>
  <li>HTML</li>
  <li>HTTP</li>
  <li>브라우저</li>
  <li>httpd</li>
</ul>


---

### HTTP/0.9 - One-line Protocol
초기 단계의 HTTP 프로토콜은 매우 간단했으며 버전 번호도 존재하지 않았다. 이 후 차후 버전과 구별하기 위해 HTTP/0.9로 불리게 되었다.
HTTP/0.9의 요청은 단일 라인으로 구성되며 (이 때문에 원라인 프로토콜로 불리기도 한다.) 요청 메서드는 `GET`이 유일했다.

```
GET /mypage.html
```

요청이 단순한 만큼 응답도 굉장히 단순했다.

```
<HTML>
A very simple HTML page
</HTML>
```

보다시피 HTTP 헤더가 없기에 오로지 HTML 파일만 전송할 수 있었으며 상태나 오류코드도 존재하지 않았다. 
문제가 발생하게 되면 문제에 대한 설명을 담은 HTML 파일만이 전송되었다.


---

### HTTP/1.0 - 확장성
HTTP/0.9의 한계는 극명했기에 개발자들은 브라우저와 서버가 조금 더 유연하게 작동할 수 있도록 빠르게 확장시켰다.

<ul>
  <li>각 요청 정보 내에 버전 정보가 담겼다.</li>
  <li>응답의 시작 부분에 상태 코드가 붙어 요청에 대한 성공 여부를 알 수 있게 되었고 결과에 따른 동작을 할 수 있게 되었다.</li>
  <li>요청과 응답에 HTTP 헤더가 생겨 메타데이터 전송이 가능해졌고 프로토콜을 좀 더 유연하게 확장할 수 있도록 만들어졌다.  </li>
  <li>HTTP 헤더가 추가됨에 따라, HTML 파일 외에 다른 문서를 전송할 수 있게 되었다.</li>
</ul>

다음은 1.0의 일반적인 요청과 응답이다.

``` html
요청
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

응답
200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML> 
A page with an image
  <IMG SRC="/myimage.gif">
</HTML>
```

다음은 이미지를 내려받기 위한 요청과 그에 대한 응답이다.
```
요청
GET /myimage.gif HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

응답
200 OK
Date: Tue, 15 Nov 1994 08:12:32 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/gif
(image content)
```


---

### HTTP/1.1 - 표준 프로토콜
1995년부터 HTTP/1.0 구현이 다양한 방향으로 또 동시에 진행됨에 있어서 혼란스러운 부분들이 많았고 이 때문에 HTTP/1.0이 출시되기 전부터 HTTP의 표준화에 대한 작업이 진행되고 있었다.
HTTP/1.1은 HTTP의 첫번째 표준 버젼으로 HTTP/1.0이 나온지 몇 달 되지 않아 발표되었다.

HTTP/1.1 은 수많은 사항들을 개선시켰다.

<ul>
  <li>커넥션을 재사용할 수 있게 하여, 커넥션을 맺기 위한 시간을 단축시키고 slow start로 인한 지연을 피할 수 있게 되었다. </li>
  <li>파이프 라이닝을 추가하여, 실행 중인 명령이 끝나기 전에 다른 명령을 시작할 수 있도록 하였다. </li>
  <li>서버에서 HTML 페이지 전부를 생성한 후에 보내는 방식이 아니라 덩어리(chunk) 단위로 쪼개서 보낼 수 있게 되었다. -> Chunked Response </li>
  <li>언어와 인코딩, 타입을 포함한 컨텐츠 옵션이 조정 가능하게 되어, 클라이언트와 서버가 데이터를 교환할 수 있는 가장 적합한 환경을 customize할 수 있게 되었다.</li>
  <li>`HOST` 헤더 덕분에, 동일 IP주소에 다른 도메인을 호스팅할 수 있게 되었다. 이러한 기능으로 서버 코로케이션이 가능케 되었다. </li>
</ul>

HTTP/1.1의 요청과 응답이다.
```
GET /en-US/docs/Glossary/Simple_header HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 20 Jul 2016 10:55:30 GMT
Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"
Keep-Alive: timeout=5, max=1000
Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
Server: Apache
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding

(content)


GET /static/img/header-background.png HTTP/1.1
Host: developer.cdn.mozilla.net
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Age: 9578461
Cache-Control: public, max-age=315360000
Connection: keep-alive
Content-Length: 3077
Content-Type: image/png
Date: Thu, 31 Mar 2016 13:34:46 GMT
Last-Modified: Wed, 21 Oct 2015 18:27:50 GMT
Server: Apache

(image content of 3077 bytes)
```

---

### HTTP/2 - 더 나은 성능의 프로토콜
몇 년에 걸쳐, 웹 페이지는 점점 복잡해졌고 하나의 어플리케이션이라 해도 이상하지 않을 정도로 성장했다.
스크립트의 양도 전과는 다르게 굉장히 방대해졌고 출력되는 미디어 데이터도 증가됨에 따라 HTTP 요청으로 전송되는 데이터의 양도 상당해졌다.
HTTP/1.1을 통한 요청은 올바른 순서에 맞게 정렬되어 전송되야 하고 병렬 커넥션은 이론적으로 사용 가능하기는 오버헤드(처리 지연)와 복잡함을 동반해야만 한다.
예시로, HTTP 파이프 라이닝은 어플리케이션 배포를 정말 어렵게만 한다.

2010년 상반기에 구글은 실험 프로토콜 SPDY를 구현하여 클라이언트와 서버 간의 데이터 교환에 대한 대안을 보여주었다. 이에 대해 웹 개발자들의 관심이 쏠릴 수 밖에 없었고,
몇 가지 문제를 해결함으로써 SPDY는 HTTP2 프로토콜의 기반이 되었다.

<ul>
  <li>바이너리 프로토콜</li>
  텍스트가 아닌 2진수로 구성 -> 파싱이 더 빠르고, 오류 발생 가능성이 낮아짐
  <li>멀티플렉싱</li>
  하나의 TCP Connection 내에 다수의 스트림을 생성
  하나의 요청이 지연되면 나머지 응답이 늦어지는 기존 파이프 라이닝과는 다르게 각각의 요청과 응답을 독립적으로 처리한다.
  -> 다수의 요청 / 응답을 동시에 처리 가능
  <li>헤더 압축</li>
  반복적으로 사용되는 헤더를 헤더 테이블 내의 인덱스로 표기 -> 헤더 크기를 현저하게 줄임
  <li>우선순위 설정</li>
  스트림 별로 우선 순위를 지정 -> 중요한 리소스의 처리 지연을 방지 
  <li>서버 푸쉬</li>
  클라이언트가 요청하지 않아도 요청이 예상되는 리소르를 서버가 미리 전송
</ul>

오늘날 HTTP가 사용되는 환경은 1990년 초반의 것과는 완전히 다르며 본래의 HTTP의 설계가 걸작임은 25년 넘는 시간 동안 웹을 진화시킴으로써 증명해왔다.

<br><br>
참조 : <br>
https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP \
https://ymcoder.tistory.com/279






