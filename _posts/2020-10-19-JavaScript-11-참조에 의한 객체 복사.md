---
title: JavaScript (11) 참조에 의한 객체 복사
tags: JavaScript
article_header:
  type: cover
  image:
---

### 개요

원시 타입을 복사하듯이 객체를 복사하려고 하면 변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 '메모리 주소’인 객체에 대한 '참조 값’이 저장된다.

객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않는다.

``` javascript
let user = { name: "John" };

let admin = user; // 참조값을 복사함
```

변수는 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장되는 것이다. 

---

### 참조에 의한 비교

객체 비교 시 동등 연산자 `==`와 일치 연산자 `===`는 동일하게 동작한다.

***비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환한다.***

예시:
``` javascript
let a = {};
let b = a; // 참조에 의한 복사

alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
alert( a === b ); // true
```

다른 예시를 살펴보자. 아래의 예시에서 두 객체는 비어있다는 점에서 같아보이지만, 독립된 객체이기 때문에 비교 시 거짓이 반환된다.

``` javascript
let a = {};
let b = {}; // 독립된 두 객체

alert( a == b ); // false
```

---

### 객체 복사, 병합과 Object.assign

객체의 복제가 정말 필요한 상황이라면 새로운 객체를 만든 다음 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사하면 된다.

예시:
``` javascript
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

Object.assign를 사용하는 방법도 있다.

문법과 동작방식은 다음과 같다.

``` javascript
Object.assign(dest, [src1, src2, src3...])
```

* dest : 목표로 하는 객체
* src1, ..., srcN : 복사하고자 하는 객체. ...은 필요에 따라 얼마든지 많은 객체를 인수로 사용할 수 있음을 나타낸다.
* 객체 src1, ..., srcN의 프로퍼티를 dest에 복사. dest를 제외한 인수(객체)의 프로퍼티 전부가 첫 번째 인수(객체)로 복사됨.
* 마지막으로 dest를 반환.

예시:
``` javascript
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
```

목표 객체(`user`)에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값이 덮어씌워 진다.

``` javascript
let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // user = { name: "Pete" }
```

---

### 중첩 객체 복사

프로퍼티는 다른 객체에 대한 참조 값일 수도 있다.

예시:
``` javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
```

clone.sizes = user.sizes로 프로퍼티를 복사하는 것만으론 객체를 복제할 수 없다.

user.sizes는 객체이기 때문에 참조 값이 복사되기 때문이다. clone.sizes = user.sizes로 프로퍼티를 복사하면 clone과 user는 같은 sizes를 공유하게 된다.

이 문제를 해결하려면 user[key]의 각 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다.

이런 방식을 '깊은 복사(deep cloning)'라고 한다.

---

참조 : <br>
* https://ko.javascript.info/object
