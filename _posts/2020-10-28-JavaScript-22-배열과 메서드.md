---
title: JavaScript (22) 배열과 메서드
tags: JavaScript
article_header:
  type: cover
  image:



---

### 개요

배열은 앞서 소개한 메서드들 외에도 다양한 메서드를 제공한다.

---

### 요소 추가·제거 메서드

#### splice

배열은 객체형에 속하므로 배열에서 요소를 하나만 지우고 싶다면 프로퍼티를 지울 때 쓰는 연산자 `delete`를 쓸 수 있다.

``` javascript
let arr = ["I", "go", "home"];

delete arr[1]; // "go"를 삭제.

alert( arr[1] ); // undefined

// delete를 써서 요소를 지우고 난 후 배열 --> arr = ["I",  , "home"];
alert( arr.length ); // 3
```

위의 예시에서 볼 수 있듯이 요소를 삭제했으나 배열의 요소는 여전히 3개인 것을 확인할 수 있다.

`delete`는 키를 `key`를 이용해 상응하는 값을 지우는 메서드이다. 그러나 요소가 삭제됨과 동시에 발생하게 된 빈 공간을 나머지 요소가 채우는 것을 바라고 개발자는 삭제 매서드를 쓴다. 그럴 때는 `splice` 메서드를 사용한다.

`splice` 메서드의 문법은 다음과 같다.

``` javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

* `index` : 조작을 가할 첫 번째 요소
* `deleteCount` : 제거하고자 하는 요소의 개수
* `elem1...elemN` : 배열에 추가할 요소

예시 :

``` javascript
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // 인덱스 1부터 요소 한 개를 제거

alert( arr ); // ["I", "JavaScript"]
```

아래 예시는 요소를 지우고 다른 요소로 채우는 모습이다.

``` javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체.
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
```

`splice`는 삭제된 요소로 구성된 배열을 반환한다.

``` javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// 처음 두 개의 요소를 삭제함
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- 삭제된 요소로 구성된 배열
```

`deleteCount`를 `0`으로 설정하면 요소를 제거하는 것 없이 새로운 요소를 추가할 수 있다.

``` javascript
let arr = ["I", "study", "JavaScript"];

// 인덱스 2부터 0개의 요소를 삭제.
// 그 후, "complex"와 "language"를 추가.
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

#### slice

문법:

``` javascript
arr.slice([start], [end])
```

`slice` 메서드는 `"start"` 인덱스부터 `"end"` 인덱스까지의 (`"end"`를 제외한) 요소를 복사한 새로운 배열을 반환한다. 둘 다 음수일 때는, 배열 끝에서부터의 요소 개수를 의미한다.

`arr.slice`는 `str.slice`와는 다르게 서브 문자열(substring) 대신 서브 배열(subarray)를 반환한다.

예시:

``` javascript
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사(인덱스가 3인 요소는 제외))

alert( arr.slice(-2) ); // s,t (인덱스가 -2인 요소부터 제일 끝 요소까지를 복사)
```

`arr.slice()`를 인수 없이 호출하게 되면 `arr`의 복사본을 만들 수 있다. 이런 방식은 기존의 배열은 내비둔 채로 배열을 조작해 새로운 배열을 만들고자 할 때 자주 사용된다.

#### concat

기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가할 때 사용하는 메서드이다.

문법:

``` javascript
arr.concat(arg1, arg2...)
```

인수엔 배열이나 값이 올 수 있으며 개수엔 제한이 없다.

예시:

``` javascript
let arr = [1, 2];

// arr의 요소 모두와 [3,4]의 요소 모두를 한데 모은 새로운 배열 생성.
alert( arr.concat([3, 4]) ); // 1,2,3,4

// arr의 요소 모두와 [3,4]의 요소 모두, [5,6]의 요소 모두를 모은 새로운 배열 생성.
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// arr의 요소 모두와 [3,4]의 요소 모두, 5와 6을 한데 모은 새로운 배열 생성.
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

`concat` 메서드에 객체가 인자로 넘어오면 통으로 복사하여 더해진다.

``` javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

인자로 받은 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable`이 있으면 `concat`은 해당 객체를 배열처럼 취급한다. 그래서 객체 프로퍼티의 값을 더할 수 있게 된다.

``` javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

---

### forEach로 반복작업 하기

`arr.forEach`는 주어진 함수를 배열 요소 각각에 대해 실행하게 해준다.

문법:

``` javascript
arr.forEach(function(item, index, array) {
  // 요소에 무언가를 할 수 있다.
});
```

`alert`창을 통해 요소를 모두 출력하는 예시이다.

``` javascript
// for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

인덱스 정보까지 더하여 출력하는 것도 가능하다.

``` javascript
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

인수로 넘긴 함수의 반환값은 무시된다.

---

### 배열 탐색하기

#### includes

`arr.includes(item, from)` : `from`부터 시작해 `item`이 있는지를 검색하고, 해당하는 요소를 발견하면 `true`를 반환한다.

예시:

``` javascript
let arr = [1, 0, false];

alert( arr.includes(1) ); // true
alert( arr.includes(2) ); // false
```

`includes`는 요소가 배열 내 존재하는지 여부를 확인할 때 유용하다. 또한 `NaN`도 제대로 처리한다.

``` javascript
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (완전 항등 비교 === 는 NaN엔 동작하지 않으므로 0이 출력되지 않는다.)
alert( arr.includes(NaN) );// true (NaN의 여부를 확인)
```

#### find와 findIndex

객체로 이루어진 배열 내에서 특정 조건에 부합하는 개체를 찾기 위해 `arr.find(fn)`을 쓸 수 있다.

문법:

``` javascript
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환.
  // 조건에 해당하는 요소가 없으면 undefined를 반환.
});
```

요소 전체를 대상으로 함수가 순차적으로 호출된다.

* `item` : 함수를 호출할 요소
* `index` : 요소의 인덱스
* `array` : 배열 자기 자신

함수가 `true`를 반환하면 탐색이 중단되고 해당 요소가 반환된다. 원하는 요소가 없으면 `undefined`가 반환된다.

아래의 예시를 보자.

``` javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

객체로 구성된 배열은 실무에서 다뤄야 할 일이 잦기 때문에 `find` 메서드를 익혀두는 것은 중요하다.

위 예시에서 `find` 안의 함수가 인자를 하나만 가지고 있는데 이러한 패턴이 가장 많이 쓰인다. 

`arr.findIndex`는 `find`와 동일한 일을 하지만 해당 요소의 인덱스를 반환한다는 점이 다르다. 조건에 맞는 요소가 없으면 `-1`을 반환한다.

#### filter

`filter` 메서드는 조건에 맞는 요소 전체를 담은 배열을 반환한다.

``` javascript
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해진다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환.
});
```

예시:

``` javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명을 반환.
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

---

### 배열을 변형하는 메서드

#### map

`arr.map`은 유용성과 사용 빈도가 높은 메서드 중 하나이다.

`map`은 배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환한다.

문법:

``` javascript
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환합니다.
});
```

아래 예시는 각 요소(문자열)의 길이를 출력해준다.

``` javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

#### sort(fn)

`arr.sort()`는 배열의 요소를 정렬한다.

예시:

``` javascript
let arr = [ 1, 2, 15 ];

// arr 내부가 재 정렬됩니다.
arr.sort();

alert( arr );  // 1, 15, 2
```

위의 예시를 보면 결과값이 `1, 2, 15`가 아니라 `1, 15, 2`인 것을 확인할 수 있다.

**요소가 문자열로 취급되어 재정렬되기 때문이다.**

모든 요소는 문자형으로 변환된 이후에 재 정렬되기 때문에 2는 15보다 큰 값으로 취급된다.

따라서 기존 정렬 기준 대신 새로운 정렬 기준을 만들려면 인수에 새로운 함수를 넘겨야 한다.

인수로 넘겨주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 한다.

``` javascript
function compare(a, b) {
  if (a > b) return 1; // 첫 번째 값이 두 번째 값보다 큰 경우
  if (a == b) return 0; // 두 값이 같은 경우
  if (a < b) return -1; //  첫 번째 값이 두 번째 값보다 작은 경우
}
```

위의 함수를 `sort` 메서드에 인수로 넣은 결과이다.

``` javascript
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

`sort`에 정렬 함수를 인수로 전달하지 않으면 사전편집 순으로 요소를 정렬한다.

정렬 함수는 어떠한 숫자든 반환할 수 있기에 이를 통해 정렬 함수를 더 간결하게 만들 수 있다.

``` javascript
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```

화살표 함수를 이용하면 위의 예시보다 더욱 간결해진다.

``` javascript
arr.sort( (a, b) => a - b );
```

#### reverse

`arr.reverse`는 `arr`의 요소를 역순으로 정렬시켜준다.

``` javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

#### split & join

`split`을 이용하면 긴 문자열 형태를 배열 형태로 전환할 수 있다. `split` 메서드는 구분자 `delim`을 기준으로 문자열을 쪼개준다.

예시:

``` javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
}
```

`split` 메서드의 두 번째 인수에 숫자를 전달하면 배열의 길이를 제한해준다. 숫자만큼의 길이를 넘어서는 요소는 무시할 수 있다.

``` javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

`arr.join(glue)`은 인수 `glue`를 사용해 배열 요소를 모두 합친 후 하나의 문자열을 만들어준다.

예시:

``` javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합칩니다.

alert( str ); // Bilbo;Gandalf;Nazgul
```

#### reduce와 reduceRight

`forEach`, `for`, `for..of`를 사용하면 배열 내 요소를 대상으로 반복 작업을 진행한다.

`map`을 사용하면 각 요소를 돌면서 반복 작업을 수행하고, 작업 결과물을 새로운 배열 형태로 반환한다.

`arr.reduce`와 `arr.reduceRight`는 위 메서드들과 유사한 작업을 수행하지만 배열을 기반으로 값 하나를 도출할 때 사용한다.

문법:

``` javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례차례 적용되고, 적용 결과는 다음 함수 호출 시 사용된다.

함수의 인수는 다음과 같다.

* `accumulator` : 이전 함수 호출의 결과. `initial`은 함수 최초 호출 시 사용되는 초기값. (옵션)
* `item` : 현재 배열 요소
* `index` : 요소의 위치
* `array` : 배열

이전 함수 호출 결과는 다음 함수를 호출할 때 첫 번째 인수(previousValue)로 사용된다.

첫 번째 인수는 앞서 호출한 함수들의 결과가 누적되어 저장되는 '누산기' 같은 것이다. 

마지막 함수까지 호출되면 이 값은 `reduce`의 반환 값이 된다.

예시:

``` javascript
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

`reduce`는 위의 예시와 같이 대게 인수를 두 개만 받는다.

위 예시의 흐름은 다음과 같다.

1. 함수 최초 호출 시, `reduce`의 마지막 인수인 `0(initial)`이 `sum(accumulator)`에 할당된다. `current(item)`엔 배열의 첫 번째 요소인 `1`이 할당된다. 함수의 결과는 `1`이 된다.
2. 두 번째 호출 시, `sum = 1`이고 여기에 배열의 두 번째 요소(`2`)가 더해지므로 결과는 `3`이 된다.
3. 세 번째 호출 시, `sum = 3`이고 여기에 배열의 다음 요소가 더해진다. 이런 과정이 계속 이어진다.

아래와 같이 초기값을 생략하는 것도 가능하다.

``` javascript
let arr = [1, 2, 3, 4, 5];

// reduce에서 초깃값을 제거함(0이 없음)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```

초기값이 없으면 배열의 첫 번째 요소를 초기값으로 사용하고 두번째 요소부터 함수를 호출한다.

그러나 초기값 없이 `reduce`를 수행할  땐 주의해야 한다. 배열이 비어있는 상태라면 `reduce` 호출 시 에러가 발생하기 때문이다.

예시:

``` javascript
let arr = [];

// TypeError: Reduce of empty array with no initial value
// 초기값이 설정되어 있다면 초기값을 반환한다.
arr.reduce((sum, current) => sum + current);
```

`arr.reduceRight`는 `reduce`와 동일한 기능을 하지만 배열의 오른쪽부터 연산을 수행한다.

---

### Array.isArray로 배열 여부 알아내기

자바스크립트에서 배열은 객체형에 속한다.

따라서 typeOf로는 일반 객체와 배열을 구분할 수 없다. 그러나 `Array.isArray(value)`를 쓰게 되면 배열인지 아닌지를 감별할 수 있다.

`value`가 배열이라면 `true`를, 아니라면 `false`를 반환한다.

``` javascript
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

---

### 배열 메서드와 'thisArg'

함수를 호출하는 대부분의 배열 메서드(`sort` 제외)는 `thisArg`라는 매개변수를 옵션으로 받을 수 있다.

`thisArg`는 자주 사용되지는 않지만 아래와 같이 활용할 수 있다.

``` javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수.
```

`thisArg`는 `func`의 `this`가 된다.

아래 예시를 보자.

``` javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

객체 `army`의 메서드를 `filter`로 넘겨주고, `thisArg`에 `army`를 지정해줌으로써 `canJoin` 메서드의 `this`를 지정해준 모습이다.


---

참조 : <br>

* https://ko.javascript.info/array-methods
